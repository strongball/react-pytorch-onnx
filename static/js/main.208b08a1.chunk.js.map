{"version":3,"sources":["utils/image.ts","utils/fns.ts","containers/Home.tsx","App.tsx","index.tsx"],"names":["loadImage","url","Promise","resolve","reject","im","Image","crossOrigin","src","onload","imageToArray","image","options","width","height","canvas","document","createElement","context","getContext","drawImage","getImageData","data","fromHWCToCHW","dataFromImage","ndarray","Float32Array","dataProcessed","ops","divseq","assign","pick","topk","k","Array","from","map","value","index","sort","a","b","slice","imageOptions","loadModel","path","session","InferenceSession","HomeContainer","props","imgRef","useRef","useState","setURL","loading","setLoading","topkResult","setTopkResult","sessionPromise","process","useEffect","current","alert","arrImage","imageCHW","inputTensor","Tensor","run","outputMap","output","values","next","topk5","console","error","modelInputChange","files","length","type","onChange","e","target","URL","createObjectURL","ref","id","item","style","paddingRight","ImageNetClassname","toString","toFixed","App","className","Home","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.208b08a1.chunk.js","sourcesContent":["import ndarray from 'ndarray';\nimport ops from 'ndarray-ops';\n\nexport function loadImage(url: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const im = new Image();\n        im.crossOrigin = 'anonymous';\n        im.src = url;\n        im.onload = () => {\n            resolve(im);\n        };\n    });\n}\n\nexport interface ImageOptions {\n    width: number;\n    height: number;\n}\nexport function imageToArray(image: HTMLImageElement, options: ImageOptions): Uint8ClampedArray {\n    const { width, height } = options;\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext('2d')!;\n    context.drawImage(image, 0, 0, width, height);\n    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n    return imageData.data;\n}\n\nexport function fromHWCToCHW(data: any, options: ImageOptions): Float32Array {\n    const { width, height } = options;\n    const dataFromImage = ndarray(new Float32Array(data), [width, height, 4]);\n    const dataProcessed = ndarray(new Float32Array(width * height * 3), [1, 3, height, width]);\n    ops.divseq(dataFromImage, 255.0);\n    ops.assign(dataProcessed.pick(0, 0, null, null), dataFromImage.pick(null, null, 0));\n    ops.assign(dataProcessed.pick(0, 1, null, null), dataFromImage.pick(null, null, 1));\n    ops.assign(dataProcessed.pick(0, 2, null, null), dataFromImage.pick(null, null, 2));\n\n    return (dataProcessed.data as any) as Float32Array;\n}\n","export interface TopkResult {\n    index: number;\n    value: number;\n}\nexport function topk(data: Float32Array, k = 5) {\n    return Array.from(data)\n        .map<TopkResult>((value, index) => ({\n            index,\n            value,\n        }))\n        .sort((a, b) => b.value - a.value)\n        .slice(0, k);\n}\n","import React, { useEffect, useState, useRef } from 'react';\nimport { Tensor, InferenceSession } from 'onnxjs';\nimport { loadImage, imageToArray, fromHWCToCHW, ImageOptions } from '../utils/image';\nimport { topk, TopkResult } from '../utils/fns';\n\nimport ImageNetClassname from '../classname.json';\n\nconst imageOptions: ImageOptions = {\n    width: 224,\n    height: 224,\n};\nasync function loadModel(path: Blob | string) {\n    const session = new InferenceSession({});\n    await session.loadModel(path as string);\n    return session;\n}\ninterface Props {}\nconst HomeContainer: React.FC<Props> = (props) => {\n    const imgRef = useRef<HTMLImageElement>(null);\n    const [url, setURL] = useState<string>();\n    const [loading, setLoading] = useState<boolean>(false);\n\n    const [topkResult, setTopkResult] = useState<TopkResult[]>([]);\n\n    const sessionPromise = useRef<Promise<InferenceSession>>(\n        loadModel(process.env.PUBLIC_URL + '/mobilenet_v3_small.onnx')\n    );\n    useEffect(() => {\n        (async () => {\n            if (!url) {\n                return;\n            }\n            if (!sessionPromise.current) {\n                alert('沒有選擇模型!');\n                return;\n            }\n            setLoading(true);\n            try {\n                const session = await sessionPromise.current;\n                const image = await loadImage(url);\n                const arrImage = imageToArray(image, imageOptions);\n                const imageCHW = fromHWCToCHW(arrImage, imageOptions);\n                const inputTensor = new Tensor(imageCHW, 'float32', [1, 3, 224, 224]);\n                const outputMap = await session.run([inputTensor]);\n                const output: Float32Array = outputMap.values().next().value.data;\n                const topk5 = topk(output);\n                setTopkResult(topk5);\n            } catch (err) {\n                console.error(err);\n            }\n            setLoading(false);\n        })();\n    }, [url]);\n\n    const modelInputChange = async (files?: File[]) => {\n        if (!files || files.length === 0) {\n            return;\n        }\n        sessionPromise.current = loadModel(files[0]);\n    };\n\n    const inputChange = (files?: File[]) => {\n        if (!files || files.length === 0) {\n            return;\n        }\n        setURL(URL.createObjectURL(files[0]));\n    };\n\n    return (\n        <div>\n            <div>\n                <span>更換模型</span>\n                <input type=\"file\" onChange={(e) => modelInputChange((e.target?.files as any) as File[])}></input>\n            </div>\n            <div>\n                <span>選擇圖片</span>\n                <input type=\"file\" onChange={(e) => inputChange((e.target?.files as any) as File[])}></input>\n            </div>\n            {loading && <div>Loading...</div>}\n            <img ref={imgRef} id=\"img\" width=\"224\" height=\"224\" src={url} />\n            <div>\n                {topkResult.map((item, index) => (\n                    <div key={item.index}>\n                        <span style={{ paddingRight: 8 }}>{index + 1}.</span>\n                        <span>{ImageNetClassname[item.index.toString() as '0']}</span>\n                        <span>({(item.value * 100).toFixed(2)}%)</span>\n                    </div>\n                ))}\n            </div>\n        </div>\n    );\n};\nexport default HomeContainer;\n","import React, { useEffect } from 'react';\nimport logo from './logo.svg';\nimport HomeContainer from './containers/Home';\nimport { Tensor, InferenceSession } from 'onnxjs';\nimport ndarray from 'ndarray';\nimport ops from 'ndarray-ops';\n\n// const image = new Image();\n// image.src = './dog.jpg';\n// image.onload = () => {\n//     console.log('onload');\n// };\nconst App: React.FC = () => {\n    // const session = new InferenceSession();\n    // useEffect(() => {\n    //     (async () => {\n    //         await session.loadModel('./model.onnx');\n    //         const data = getImageData();\n    //         const pData = preprocess(data).data;\n    //         const inputTensor = new onnx.Tensor(pData as any, 'float32', [1, 3, 224, 224]);\n    //         const outputMap = await session.run([inputTensor]);\n    //         const outputData = outputMap.values().next().value.data;\n    //         console.log(outputData.indexOf(Math.max(...outputData)));\n    //         console.log(outputData);\n    //     })();\n    //     // loadMobileNet();\n    // }, []);\n    return (\n        <div className=\"App\">\n            <HomeContainer></HomeContainer>\n        </div>\n    );\n};\n\n// function getImageData(modelWidth = 224, modelHeight = 224) {\n//     const canvas = document.createElement('canvas');\n//     canvas.width = modelWidth;\n//     canvas.height = modelHeight;\n//     const context = canvas.getContext('2d')!;\n//     context.drawImage(image, 0, 0);\n\n//     const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n//     return imageData.data;\n// }\n\n// function preprocess(data: any, width = 224, height = 224) {\n//     const dataFromImage = ndarray(new Float32Array(data), [width, height, 4]);\n//     const dataProcessed = ndarray(new Float32Array(width * height * 3), [1, 3, height, width]);\n\n//     ops.divseq(dataFromImage, 255.0);\n//     ops.assign(dataProcessed.pick(0, 0, null, null), dataFromImage.pick(null, null, 0));\n//     ops.assign(dataProcessed.pick(0, 1, null, null), dataFromImage.pick(null, null, 1));\n//     ops.assign(dataProcessed.pick(0, 2, null, null), dataFromImage.pick(null, null, 2));\n\n//     return dataProcessed;\n// }\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n// import reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals();\n"],"sourceRoot":""}